# MITRE ATT&CK Mapper (Python)
# Dependencies: pip install requests stix2
# Usage:
#   python attack_mapper.py T1059.001 T1210 T1021
#   python attack_mapper.py --from-file ids.txt
#   python attack_mapper.py --export-layer coverage_layer.json T1059 T1047

import argparse
import json
import sys
from pathlib import Path
from typing import Dict, List, Set, Tuple
import requests

CTI_STIX_URL = "https://raw.githubusercontent.com/mitre/cti/master/enterprise-attack/enterprise-attack.json"

def fetch_enterprise_attack() -> Dict:
    r = requests.get(CTI_STIX_URL, timeout=60)
    r.raise_for_status()
    return r.json()

def index_attack(stix: Dict) -> Tuple[Dict[str, Dict], Dict[str, Dict], Dict[str, List[str]]]:
    """Return (techniques_by_extid, tactics_by_shortname, technique_to_tactics)."""
    objs = stix.get("objects", [])
    techniques_by_extid: Dict[str, Dict] = {}
    tactics_by_shortname: Dict[str, Dict] = {}
    technique_to_tactics: Dict[str, List[str]] = {}

    # Tactics
    for o in objs:
        if o.get("type") == "x-mitre-tactic" and not o.get("x_mitre_deprecated", False):
            tactics_by_shortname[o["x_mitre_shortname"]] = o

    # Techniques + sub-techniques
    for o in objs:
        if o.get("type") == "attack-pattern" and not o.get("x_mitre_deprecated", False):
            ext_refs = o.get("external_references", [])
            extid = None
            for ref in ext_refs:
                if ref.get("source_name") in ("mitre-attack", "mitre-attack-id"):
                    extid = ref.get("external_id")
                    break
            if not extid:
                continue
            techniques_by_extid[extid] = o
            phases = [p["phase_name"] for p in o.get("kill_chain_phases", []) if p.get("kill_chain_name") == "mitre-attack"]
            technique_to_tactics[extid] = phases
    return techniques_by_extid, tactics_by_shortname, technique_to_tactics

def normalize_ids(ids: List[str]) -> List[str]:
    return [i.strip().upper().replace(" ", "") for i in ids if i.strip()]

def map_ids(ids: List[str], tech_idx: Dict[str, Dict], t2tac: Dict[str, List[str]], tac_idx: Dict[str, Dict]) -> List[Dict]:
    out = []
    for tid in ids:
        tech = tech_idx.get(tid)
        if not tech:
            out.append({"technique_id": tid, "name": None, "tactics": [], "platforms": [], "is_subtechnique": False, "exists": False})
            continue
        name = tech.get("name")
        tactics_short = t2tac.get(tid, [])
        tactics_full = [tac_idx[s]["name"] for s in tactics_short if s in tac_idx]
        platforms = tech.get("x_mitre_platforms", [])
        out.append({
            "technique_id": tid,
            "name": name,
            "tactics": tactics_full,
            "platforms": platforms,
            "is_subtechnique": tech.get("x_mitre_is_subtechnique", False),
            "exists": True
        })
    return out

def to_markdown(rows: List[Dict]) -> str:
    header = "| Technique ID | Technique | Tactics | Platforms | Sub-technique |\n|---|---|---|---|---|"
    lines = [header]
    for r in rows:
        if not r["exists"]:
            lines.append(f"| {r['technique_id']} | ❌ Not found |  |  |  |")
            continue
        lines.append(
            f"| {r['technique_id']} | {r['name']} | {', '.join(r['tactics'])} | {', '.join(r['platforms'])} | {'Yes' if r['is_subtechnique'] else 'No'} |"
        )
    return "\n".join(lines)

def make_navigator_layer(rows: List[Dict], name: str = "Coverage Layer") -> Dict:
    # ATT&CK Navigator layer v4+
    techniques = []
    for r in rows:
        if r["exists"]:
            techniques.append({
                "techniqueID": r["technique_id"],
                "tactic": None,  # Navigator will auto-place by matrix unless specified
                "score": 1,
                "enabled": True,
                "comment": r["name"],
                "metadata": [{"name": "Platforms", "value": ", ".join(r["platforms"])}],
                "color": "",
                "showSubtechniques": True
            })
    layer = {
        "version": "4.5",
        "name": name,
        "description": "Autogenerated coverage layer",
        "domain": "enterprise-attack",
        "filters": {"platforms": []},
        "sorting": 0,
        "viewMode": 0,
        "hideDisabled": False,
        "techniques": techniques,
        "gradient": {"colors": ["#ffffff", "#ff6666"], "minValue": 0, "maxValue": 1},
        "legendItems": [{"label": "Covered", "color": "#ff6666"}],
        "metadata": [],
        "showTacticRowBackground": False,
        "tacticRowBackground": "#dddddd",
        "selectTechniquesAcrossTactics": True
    }
    return layer

def read_ids_from_file(p: Path) -> List[str]:
    txt = p.read_text(encoding="utf-8")
    ids: Set[str] = set()
    for line in txt.splitlines():
        for token in line.replace(",", " ").split():
            ids.add(token.strip())
    return sorted(ids)

def main():
    ap = argparse.ArgumentParser(description="MITRE ATT&CK mapper (enterprise) using MITRE CTI STIX data.")
    ap.add_argument("technique_ids", nargs="*", help="Technique IDs like T1059, T1059.001, T1047")
    ap.add_argument("--from-file", type=Path, help="File containing technique IDs (comma/space/newline separated)")
    ap.add_argument("--export-markdown", type=Path, help="Write a markdown coverage table")
    ap.add_argument("--export-json", type=Path, help="Write JSON results")
    ap.add_argument("--export-layer", type=Path, help="Write an ATT&CK Navigator layer JSON")
    ap.add_argument("--layer-name", default="Coverage Layer", help="Name for the Navigator layer")
    args = ap.parse_args()

    ids: List[str] = []
    if args.from_file:
        ids.extend(read_ids_from_file(args.from_file))
    if args.technique_ids:
        ids.extend(args.technique_ids)
    if not ids:
        print("No technique IDs provided.", file=sys.stderr)
        sys.exit(2)

    ids = normalize_ids(ids)
    stix = fetch_enterprise_attack()
    tech_idx, tac_idx, t2tac = index_attack(stix)
    rows = map_ids(ids, tech_idx, t2tac, tac_idx)

    # stdout concise JSON
    print(json.dumps(rows, indent=2))

    if args.export_markdown:
        args.export_markdown.write_text(to_markdown(rows), encoding="utf-8")
    if args.export_json:
        args.export_json.write_text(json.dumps(rows, indent=2), encoding="utf-8")
    if args.export_layer:
        layer = make_navigator_layer(rows, name=args.layer_name)
        args.export_layer.write_text(json.dumps(layer, indent=2), encoding="utf-8")

if __name__ == "__main__":
    main()